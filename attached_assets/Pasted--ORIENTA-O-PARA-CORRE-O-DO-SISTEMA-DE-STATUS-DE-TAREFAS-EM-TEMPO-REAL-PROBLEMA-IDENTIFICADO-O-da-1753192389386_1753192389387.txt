üö® ORIENTA√á√ÉO PARA CORRE√á√ÉO DO SISTEMA DE STATUS DE TAREFAS EM TEMPO REAL
PROBLEMA IDENTIFICADO
O dashboard est√° manipulando informa√ß√µes de status das tarefas ao inv√©s de buscar dados em tempo real da API do Monde. H√° listas est√°ticas hardcoded e l√≥gica que tenta "adivinhar" o status das tarefas.
CORRE√á√ïES NECESS√ÅRIAS
1. REMOVER TODAS AS LISTAS EST√ÅTICAS
Localizar e deletar:
javascript// DELETAR ESTAS LINHAS (por volta da linha 1000-1100)
const DELETED_TASKS_IN_MONDE = [
  "teste",
  "TESSY ANNE", 
  // ... toda a lista
];
2. REESCREVER A FUN√á√ÉO isTaskDeleted
Substituir a fun√ß√£o atual por:
javascriptconst isTaskDeleted = (task: any) => {
  // USAR APENAS OS CAMPOS DA API, SEM MANIPULA√á√ÉO
  return task.attributes?.deleted === true || 
         task.attributes?.is_deleted === true ||
         task.attributes?.status === 'deleted' ||
         task.attributes?.status === 'archived';
};
3. CRIAR ENDPOINT ESPEC√çFICO PARA STATUS REAL
Adicionar novo endpoint no backend (/api/monde/tarefas/[id]/status):
javascript// Endpoint que busca o status real e atualizado de uma tarefa espec√≠fica
app.get('/api/monde/tarefas/:id/status', async (req, res) => {
  const { id } = req.params;
  
  try {
    const response = await mondeAPI.get(`/tasks/${id}`);
    const task = response.data.data;
    
    // Retornar status real sem manipula√ß√£o
    res.json({
      id: task.id,
      status: {
        completed: task.attributes.completed,
        deleted: task.attributes.deleted || false,
        archived: task.attributes.archived || false,
        visualized: task.attributes.visualized,
        due: task.attributes.due,
        updated_at: task.attributes['updated-at'] || task.attributes['registered-at']
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar status' });
  }
});
4. REATIVAR E MELHORAR O SISTEMA DE SINCRONIZA√á√ÉO AUTOM√ÅTICA
Localizar e descomentar/melhorar o polling (por volta da linha 2500):
javascript// SUBSTITUIR O POLLING COMENTADO POR:
useEffect(() => {
  // Sincroniza√ß√£o inteligente - mais frequente quando h√° atividade
  let syncInterval = 5000; // 5 segundos padr√£o
  let lastActivityTime = Date.now();
  
  const smartSync = async () => {
    try {
      const hasRecentActivity = (Date.now() - lastActivityTime) < 30000; // 30 segundos
      
      if (hasRecentActivity) {
        syncInterval = 3000; // 3 segundos se teve atividade recente
      } else {
        syncInterval = 10000; // 10 segundos se n√£o teve atividade
      }
      
      await checkForChanges();
    } catch (error) {
      console.error('Erro na sincroniza√ß√£o:', error);
    }
  };
  
  const interval = setInterval(smartSync, syncInterval);
  
  // Detectar atividade do usu√°rio
  const activityHandler = () => {
    lastActivityTime = Date.now();
  };
  
  window.addEventListener('mousemove', activityHandler);
  window.addEventListener('keypress', activityHandler);
  
  return () => {
    clearInterval(interval);
    window.removeEventListener('mousemove', activityHandler);
    window.removeEventListener('keypress', activityHandler);
  };
}, []);
5. MELHORAR A FUN√á√ÉO checkForChanges
Reescrever para ser mais eficiente:
javascriptconst checkForChanges = async () => {
  try {
    const token = localStorage.getItem('keeptur-token');
    if (!token) return;
    
    // Buscar apenas mudan√ßas desde a √∫ltima sincroniza√ß√£o
    const lastSync = localStorage.getItem('lastSyncTime') || new Date(Date.now() - 300000).toISOString();
    
    const response = await fetch(`/api/monde/tarefas?updated_since=${lastSync}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'X-Request-ID': crypto.randomUUID() // Para evitar cache
      }
    });
    
    if (!response.ok) return;
    
    const data = await response.json();
    const updatedTasks = data.data || [];
    
    if (updatedTasks.length > 0) {
      console.log(`üîÑ ${updatedTasks.length} tarefas atualizadas`);
      
      // Atualizar apenas as tarefas que mudaram
      setAllTasks(prevTasks => {
        const taskMap = new Map(prevTasks.map(t => [t.id, t]));
        
        updatedTasks.forEach(updatedTask => {
          taskMap.set(updatedTask.id, updatedTask);
        });
        
        return Array.from(taskMap.values());
      });
      
      // Salvar timestamp da √∫ltima sincroniza√ß√£o
      localStorage.setItem('lastSyncTime', new Date().toISOString());
      
      // For√ßar re-render apenas se necess√°rio
      if (updatedTasks.some(t => tasks.find(task => task.id === t.id))) {
        setTasks(prev => [...prev]); // For√ßa re-render
      }
    }
  } catch (error) {
    console.error('Erro na sincroniza√ß√£o:', error);
  }
};
6. IMPLEMENTAR WEBSOCKET PARA ATUALIZA√á√ïES EM TEMPO REAL
Adicionar suporte a WebSocket (opcional mas recomendado):
javascript// No in√≠cio do componente Dashboard
useEffect(() => {
  const ws = new WebSocket('wss://seu-servidor.com/ws/tasks');
  
  ws.onopen = () => {
    console.log('üîå WebSocket conectado');
    ws.send(JSON.stringify({ 
      type: 'subscribe', 
      token: localStorage.getItem('keeptur-token') 
    }));
  };
  
  ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    
    if (message.type === 'task_updated') {
      // Atualizar tarefa espec√≠fica sem recarregar tudo
      setAllTasks(prev => prev.map(task => 
        task.id === message.taskId ? message.task : task
      ));
    }
  };
  
  ws.onerror = (error) => {
    console.error('WebSocket erro:', error);
    // Fallback para polling se WebSocket falhar
  };
  
  return () => ws.close();
}, []);
7. REMOVER TODA MANIPULA√á√ÉO DE STATUS
Procurar e remover/simplificar:

Fun√ß√£o getTaskStatus - deve apenas ler da API
Fun√ß√£o getTasksByStatus - n√£o deve ter l√≥gica complexa
Remover verifica√ß√µes de hist√≥rico para determinar status

8. ADICIONAR CACHE INTELIGENTE
javascript// Cache com TTL (Time To Live)
const taskCache = new Map();
const CACHE_TTL = 30000; // 30 segundos

const getCachedTask = (taskId) => {
  const cached = taskCache.get(taskId);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  taskCache.delete(taskId);
  return null;
};

const setCachedTask = (taskId, taskData) => {
  taskCache.set(taskId, {
    data: taskData,
    timestamp: Date.now()
  });
};
9. IMPLEMENTAR INDICADORES VISUAIS DE SINCRONIZA√á√ÉO
javascript// Adicionar estado para mostrar status de sincroniza√ß√£o
const [syncStatus, setSyncStatus] = useState({
  isSyncing: false,
  lastSync: null,
  error: null
});

// Mostrar indicador no UI
{syncStatus.isSyncing && (
  <div className="fixed bottom-4 right-4 bg-blue-500 text-white px-3 py-2 rounded-lg shadow-lg flex items-center">
    <div className="animate-spin rounded-full h-4 w-4 border-2 border-white mr-2"></div>
    Sincronizando...
  </div>
)}
10. CONFIGURA√á√ÉO DE DESENVOLVIMENTO
Adicionar vari√°veis de ambiente:
env# .env
VITE_SYNC_INTERVAL=3000 # Intervalo de sincroniza√ß√£o em ms
VITE_ENABLE_WEBSOCKET=true # Habilitar WebSocket
VITE_CACHE_TTL=30000 # Tempo de vida do cache
RESUMO DAS MUDAN√áAS CR√çTICAS

NUNCA usar listas est√°ticas de IDs
SEMPRE confiar nos dados da API
IMPLEMENTAR sincroniza√ß√£o autom√°tica eficiente
ADICIONAR indicadores visuais de sincroniza√ß√£o
USAR cache inteligente para reduzir requisi√ß√µes
CONSIDERAR WebSocket para tempo real verdadeiro

